import React, {
  useRef,
  useState,
  useMemo,
  useCallback,
  useEffect,
} from 'react';
import {
  StyleSheet,
  PanResponder,
  Animated,
  Text,
  View,
  TouchableOpacity,
  TouchableWithoutFeedback,
  Keyboard,
  Dimensions,
} from 'react-native';
import WritingOption from './markUpOptions/writingOptions';
import ColorPicker from './markUpOptions/colorPicker';
import ThicknessPicker from './markUpOptions/thicknessPicker';
import { MarkupMode } from './textCanvas';
import ActiveIcon from './markUpOptions/activeIcon';

interface MarkUpModalProps {
  onModeChange: (mode: MarkupMode) => void;
  currentMode: MarkupMode;
  visible?: boolean;
  onColorChange?: (color: string) => void;
  onThicknessChange?: (thickness: number) => void;
}

const COLLAPSED_SIZE = 100;
const EXPANDED_SIZE = 600;
const MARGIN = 40;

const MarkUpModal: React.FC<MarkUpModalProps> = ({
  onModeChange,
  currentMode,
  visible = true,
  onColorChange,
  onThicknessChange,
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [side, setSide] = useState<'left' | 'right'>('right');
  const screenWidth = useRef(Dimensions.get('window').width).current;

  const [isLocked, setIsLocked] = useState(false);
  const [isPressing, setIsPressing] = useState(false);
  const [selectedColor, setSelectedColor] = useState('#000000');
  const [selectedThickness, setSelectedThickness] = useState(4);

  // Initial Position: Bottom Right
  const pan = useRef(
    new Animated.ValueXY({
      x: screenWidth - COLLAPSED_SIZE - MARGIN,
      y: 0,
    })
  ).current;

  const expandAnim = useRef(new Animated.Value(0)).current;
  const backdropOpacity = useRef(new Animated.Value(0)).current;
  const lockProgressAnim = useRef(new Animated.Value(0)).current;

  const handleToggle = useCallback(() => {
    if (isLocked) return;
    Keyboard.dismiss();

    const toValue = isOpen ? 0 : 1;
    setIsOpen(!isOpen);

    Animated.parallel([
      Animated.spring(expandAnim, {
        toValue,
        useNativeDriver: false,
        friction: 8,
        tension: 40,
      }),
      Animated.timing(backdropOpacity, {
        toValue,
        duration: 300,
        useNativeDriver: true,
      }),
    ]).start();
  }, [isOpen, expandAnim, backdropOpacity, isLocked]);

  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () => true,
        onMoveShouldSetPanResponder: (_, gesture) => {
          if (isLocked || isOpen) return false;
          return Math.abs(gesture.dx) > 5 || Math.abs(gesture.dy) > 5;
        },
        onPanResponderGrant: () => {
          if (isLocked || isOpen) return;
          pan.extractOffset();

          setIsPressing(true);
          lockProgressAnim.setValue(0);
          Animated.timing(lockProgressAnim, {
            toValue: 1,
            duration: 1000,
            useNativeDriver: false,
          }).start(({ finished }) => {
            if (finished) {
              setIsLocked((prev) => !prev);
              setIsPressing(false);
            }
          });
        },
        onPanResponderMove: (e, gesture) => {
          if (Math.abs(gesture.dx) > 5 || Math.abs(gesture.dy) > 5) {
            setIsPressing(false);
            lockProgressAnim.stopAnimation();
          }
          if (isLocked || isOpen) return;

          Animated.event([null, { dx: pan.x, dy: pan.y }], {
            useNativeDriver: false,
          })(e, gesture);
        },
        onPanResponderRelease: (_, gesture) => {
          setIsPressing(false);
          lockProgressAnim.stopAnimation();
          pan.flattenOffset();

          // Side detection: check where the center of the circle is
          const currentX = (pan.x as any)._value + COLLAPSED_SIZE / 2;
          setSide(currentX < screenWidth / 2 ? 'left' : 'right');

          if (
            Math.abs(gesture.dx) < 5 &&
            Math.abs(gesture.dy) < 5 &&
            !isLocked &&
            !isOpen
          ) {
            handleToggle();
          }
        },
      }),
    [pan, isLocked, isOpen, handleToggle, lockProgressAnim, screenWidth]
  );

  // Interpolations
  const modalWidth = expandAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [COLLAPSED_SIZE, EXPANDED_SIZE],
  });

  // If on the right, we translate left by the amount we grew to keep the right edge stable
  const translateX = expandAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, side === 'right' ? -(EXPANDED_SIZE - COLLAPSED_SIZE) : 0],
  });

  const contentOpacity = expandAnim.interpolate({
    inputRange: [0, 0.8, 1],
    outputRange: [0, 0, 1],
  });

  if (!visible) return null;

  return (
    <View style={StyleSheet.absoluteFill} pointerEvents="box-none">
      {!isLocked && (
        <TouchableWithoutFeedback onPress={handleToggle}>
          <Animated.View
            style={[
              styles.backdrop,
              {
                opacity: backdropOpacity,
                pointerEvents: isOpen ? 'auto' : 'none',
              },
            ]}
          />
        </TouchableWithoutFeedback>
      )}

      <Animated.View
        {...panResponder.panHandlers}
        style={[
          styles.circle,
          currentMode && styles.circleActive,
          isLocked && styles.circleLocked,
          {
            width: modalWidth,
            // We use pan.getLayout() for the core movement
            // and add translateX for the expansion shift
            transform: [
              { translateX: Animated.add(pan.x, translateX) },
              { translateY: pan.y },
            ],
          },
        ]}
      >
        {isPressing && !isLocked && !isOpen && (
          <View style={styles.progressBorderContainer}>
            <Animated.View
              style={[
                styles.progressBorder,
                {
                  borderColor: '#4CAF50',
                  transform: [
                    {
                      scale: lockProgressAnim.interpolate({
                        inputRange: [0, 1],
                        outputRange: [0, 1],
                      }),
                    },
                  ],
                },
              ]}
            />
          </View>
        )}

        {!isOpen ? (
          <ActiveIcon
            mode={currentMode}
            color={selectedColor}
            thickness={selectedThickness}
          />
        ) : (
          <Animated.View
            style={[styles.optionsContainer, { opacity: contentOpacity }]}
          >
            <View style={styles.row}>
              <WritingOption
                currentMode={currentMode || 'Draw'}
                onModeChange={(mode) => onModeChange(mode)}
              />
              <View style={styles.divider} />
              <ColorPicker
                current={selectedColor}
                onSelect={(c) => {
                  setSelectedColor(c);
                  onColorChange?.(c);
                }}
              />
              <View style={styles.divider} />
              <ThicknessPicker
                current={selectedThickness}
                selectedColor={selectedColor}
                onSelect={(t) => {
                  setSelectedThickness(t);
                  onThicknessChange?.(t);
                }}
              />
              <View style={styles.divider} />
              <TouchableOpacity
                onPress={() => (isLocked ? setIsLocked(false) : handleToggle())}
                activeOpacity={0.7}
              >
                <Text
                  style={[
                    styles.closeText,
                    { color: isLocked ? '#FFA500' : '#ff4444' },
                  ]}
                >
                  {isLocked ? 'Unlock' : 'X'}
                </Text>
              </TouchableOpacity>
            </View>
          </Animated.View>
        )}
      </Animated.View>
    </View>
  );
};

const styles = StyleSheet.create({
  backdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
  },
  circle: {
    height: 100,
    backgroundColor: '#1b2026',
    position: 'absolute',
    bottom: 60,
    left: 0, // IMPORTANT: Base everything off left to prevent jumping
    borderRadius: 50,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 10,
    zIndex: 1000,
    overflow: 'hidden',
  },
  circleActive: { backgroundColor: '#2a3139' },
  circleLocked: { borderWidth: 2, borderColor: '#4CAF50' },
  progressBorderContainer: {
    position: 'absolute',
    top: -6,
    left: -6,
    right: -6,
    bottom: -6,
    borderRadius: 56,
    overflow: 'hidden',
  },
  progressBorder: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    borderRadius: 56,
    borderWidth: 4,
  },
  optionsContainer: { width: '100%', paddingHorizontal: 25 },
  row: {
    flexDirection: 'row',
    width: '100%',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  divider: { width: 1, height: 35, backgroundColor: 'rgba(255,255,255,0.1)' },
  closeText: { fontWeight: 'bold', fontSize: 20, padding: 10 },
});

export default React.memo(MarkUpModal);
